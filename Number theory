Extended eucleadian algorithm used to solve equation
12x+10y=2      here gcd(12,10)=2
                       gcd(10,2)=0
                        gcd(2,0)=0
2x+0y=2    here x=1,y=0
10x+2y=2 here x=0,y=1{swapped value}
x=y1,
y=x1-[12/10]y1
  =x1-[a/b]y1
Code:

#include<iostream>
using namespace std;

int gcd(int a, int b) {
    if (b == 0) return a;
    return gcd(b, a % b);
}

void ex_gcd(int a, int b, int &x, int &y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return;
    }
    int x1, y1;
    ex_gcd(b, a % b, x1, y1);
    x = y1;
    y = x1 - y1 * (a / b);
}

int main() {
    int a, b, c;
    cout << "Enter a, b, c for equation ax + by = c : ";
    cin >> a >> b >> c;

    int x, y;
    ex_gcd(a, b, x, y);

    int g = a * x + b * y;   // gcd(a,b)

    if (c % g != 0) {
        cout << "No integer solution exists.\n";
        return 0;
    }

    int mul = c / g;
    x *= mul;
    y *= mul;

    cout << "One solution:\n";
    cout << "x = " << x << "\n";
    cout << "y = " << y << "\n";

    return 0;
}
//
#include<iostream>
using namespace std;
int gcd(int a,int b)
{
    if(b==0) return a;
    return gcd(b,a%b);
}
int lcm(int a,int b)
{
    return (a/gcd(a,b)*b);
}
int main()
{
    cout<<lcm(5,15)<<endl;
}

//Divisor cnt:
for(long long i=1;i*i<=n;i++){
if(n%i==0) cnt+=2;
long long other=n/i;
if(other ==i) cnt+=1;
if a number has odd no of divisors it is a square number
//Prime of eratosthenes
n=1e6//10^6
vecot<boo>isPrime(n,true)
isPrime[0]=isPrime[1]=false;
for(int i=2;i<n;i++){
if(!isPrime[i] continue;
for(int j=2*i;j<n;j+=i){
isPrime[j]=false;
//Co-prime of a certain number
int phi(int n){
for(int i=0;i<n;i++){
if((gcd(i,n)==1) ans++;
All numbers below a prime are coprime with it
so phi(prime)=prime-1;
phi(prime^ n)=prime^n -prime^ (n-1)//those no divided by that prime are excluded
}
// generate coprime for every no from 1 to n
Multiplicative function:  phi(a) * phi(b)=phi(a*b)
phi(n)=n* (1-1/pi)
vector<int>phi_arr(N);
void allPhi(){
for(int i=1;i<N;i++) phi_arr[i]=i;
for(int i=2;i<N;i++){
if(phi_arr[i]!=i ) continue;
for(int j=i;j<N;j+=i){
phi_arr[j]/=i;
phi_arr[j]*=(i-1);// * (i-1)/i;
int main()
{
allPhi();
int n;
cin>>n;
cout<<phi_arr[n]<<endl;
}
//Binary exponentiation
a^n %p 
a^n={  1   if n==0      
      (a^n/2)^2    if n>0 && n even
       (a^ n-1/2)^2 .a    if n>0 && n odd
int bin_ex(int a,int b,int n)//a^b %m
{
if(b==0) return 1;
if(b%2==1){
return (bin_ex(a,b-1,m)*a )%m;
}
else{
int res=bin_ex(a,b/2,m);
return (res* res)% m;
}
Fermats little theorem
if p is a prime number then a^p = a(mod p)




